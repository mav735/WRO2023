#pragma config(Sensor, S1,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S2,     ,               sensorEV3_Color, modeEV3Color_RGB_Raw)
#pragma config(Sensor, S3,     ,               sensorI2CCustom9V)
#pragma config(Sensor, S4,     ,               sensorI2CCustom9V)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Medium, openLoop, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorEV3_Medium, openLoop, encoder)
//*!!Code autobmatically generated by 'ROBOTC' configuration wizard               !!*//

#define READ

int encodersMarkers_forDop[2] = {475, 570};

int encodersMarkers[2] = {645, 735};
short markerColors[2] = {-2, -2};
short inverseMarkerColors[2] = {-2, -2};


int encodersElements[4] = {0, 130, 260, 390};
short elementsColors[4] = {-2, -2, -2, -2};
int encodersWelems[2] = {0, 150};
short welemsColors[2] = {0, 0};
short gotElements[4] = {0, 0, 0, 0};


bool markerOnBigShip[2] = {false, false};
bool whiteOnBigShip = false;
int elemsBigShip = 0;


bool inverseMarkerOnSmallShip[2] = {false, false};
bool whiteOnSmallShip = false;
int elemsSmallShip = 0;

#include "include/includes.h"



void start(){
    stopMove(250);
	setDefaultLine();
    readColors(encodersMarkers, markerColors, 2, &CDSensor3, 0);

    inverseMarkerColors[0] = 7 - markerColors[0];
    inverseMarkerColors[1] = 7 - markerColors[1];

    arcEnc(-50, 50, 50, 50, 135);
    changePosGrabberC(50, grabberC.maxUpWithoutShip);
    lineFollowEncoder(50, 55, 55, 300);
    arcEnc(-55, 55, 55, 20, 305);
    stopMove(100);
    arcEnc(25, -25, 80, 20, 165);
    smartTurnRight_enc(40, 80, 60);
    soundColOfElements(markerColors, 2);
    lineFollowCross(100, 100, 1);
    reactiveTurnLeft();
    changePosGrabberC(50, grabberC.maxUpWithoutShip);
    setDefaultLineGreyCross();
    lineFollowEncoder(100, 100, 30, 450);
    lineFollowCross(30, 25, 1);
    stopMove(200);
}


void readingElements(){
    arcEnc(25, -25, 60, 25, 65);
    stopMove(150);
    arcAngle(-25, -25, -80, -25, 80);
    arcAngle(-25, -25, -25, -25, 10);
    stopMove(150);
    arcEnc(25, -25, 25, 25, 100);
    stopMove(200);
    readColors(encodersElements, elementsColors, 4, &CDSensor3, 0);
    arcEnc(-25, 25, 60, 25, 365);
    arcEnc(-25, 25, 25, 25, 35);
    stopMove(0);
    soundColOfElements(elementsColors, 4);
    stopMove(150);
    arcAngle(40, -11.2, 60, 30, 85);
    arcAngle(30, -8.4, 30, 30, 5);
    stopMove(200);
    changePosGrabberC(40, grabberC.maxDown);
    lineFollowEncoder(25, 25, 25, 135);
    stopMove(300);
}

void readingElements_fast(){
    arcEnc(25, -25, 60, 25, 65);
    stopMove(200);
    arcAngle(-25, -25, -80, -25, 80);
    arcAngle(-25, -25, -25, -25, 10);
    stopMove(100);
    arcEnc(25, -25, 25, 25, 100);
    stopMove(200);
    readColors(encodersElements, elementsColors, 4, &CDSensor3, 0);
    arcEnc(-25, 25, 60, 25, 365);
    arcEnc(-25, 25, 25, 25, 35);
    stopMove(0);
    soundColOfElements(elementsColors, 4);
    stopMove(200);
    arcAngle(40, -11.2, 60, 30, 85);
    arcAngle(30, -8.4, 30, 30, 5);
    stopMove(200);
    changePosGrabberC(50, grabberC.maxDown);
    lineFollowEncoder(25, 25, 25, 105);
    stopMove(200);
}

void getElements(short firstColor, short secondColor, short amount=2, short finalPos=0, short getLast=0){
    short turnsEncElements[4] = {70, 25, -25, -70};
    short degreesElements[4] = {203, 180, 180, 203};
    bool markersFound[2] = {false, false};
    short nowPosition = 0;
    short indexesNeed[2] = {0, 1};
    if (getLast){
    	for(short i = 0; i < 4; i++){
    		if ((!gotElements[i]) && (!markersFound[0])){
    			indexesNeed[0] = i;
    			gotElements[i] = 1;
    			markersFound[0] = true;
    		}
    		else if ((!gotElements[i]) && (!markersFound[1])){
    			indexesNeed[1] = i;
    			gotElements[i] = 1;
    			markersFound[1] = true;
    		}
    	}
    }
    else{
	    for (short i = 0; i < 4; i++){
	        if ((firstColor == elementsColors[i]) && (!markersFound[0])){
	            markersFound[0] = true;
	            indexesNeed[0] = i;
	        }
	        else if ((secondColor == elementsColors[i]) && (!markersFound[1])){
	            markersFound[1] = true;
	            indexesNeed[1] = i;
	        }
	    }
	}

    gotElements[indexesNeed[0]] = 1;
    gotElements[indexesNeed[1]] = 1;

    for (short i = 0; i < amount; i++){
        short angle = turnsEncElements[indexesNeed[i]] - nowPosition;
        short way = sgn(angle);
        arcEnc(way * 30, way * 30, way * 50, way * 30, fabs(angle));


        stopMove(150);
        arcEnc(-25, 25, 25, 25, 20);
        changePosGrabberD(100, grabberD.openMin);
        stopMove(100);
        arcEnc(-25, 25, 40, 25, degreesElements[indexesNeed[i]] - 60);
        changePosGrabberD(100, grabberD.close);
        arcEnc(-25, 25, 25, 25, 40);
        stopMove(150);
        arcEnc(25, -25, 40, 25, degreesElements[indexesNeed[i]] - 20);
        arcEnc(25, -25, 25, 25, 20);
        stopMove(150);
        nowPosition = turnsEncElements[indexesNeed[i]];
        elementsColors[indexesNeed[i]] = -1;
    }

    if (finalPos == 0) {
        short signPos = sgn(nowPosition);
        short angle = angleToEnc(20, 20, 180) - fabs(nowPosition);
        if (signPos > 0){
            smartTurnLeft_enc(40, 80, 60, fabs(angle));
        }
        else{
            smartTurnRight_enc(40, 80, 60, fabs(angle));
        }
    } else {
        short signPos = sgn(nowPosition);
        short angle = fabs(nowPosition);
        if (signPos > 0) {
            arcEnc(-30, -30, -40, -30, fabs(angle));
        } else {
            arcEnc(30, 30, 40, 30, fabs(angle));
        }
    }
}

void getElementsByPos(short pos1, short pos2, short amount=2, short finalPos=0){
    short turnsEncElements[4] = {70, 25, -25, -70};
    short degreesElements[4] = {203, 180, 180, 203};
	short nowPosition = 0;

    gotElements[pos1] = 1;
    gotElements[pos2] = 1;
    short indexesNeed[2] = {pos1, pos2};

    for (short i = 0; i < amount; i++){
        short angle = turnsEncElements[indexesNeed[i]] - nowPosition;
        short way = sgn(angle);
        arcEnc(way * 30, way * 30, way * 50, way * 30, fabs(angle));


        stopMove(150);
        arcEnc(-25, 25, 25, 25, 20);
        changePosGrabberD(100, grabberD.openMin);
        stopMove(100);
        arcEnc(-25, 25, 40, 25, degreesElements[indexesNeed[i]] - 60);
        changePosGrabberD(100, grabberD.close);
        arcEnc(-25, 25, 25, 25, 40);
        stopMove(150);
        arcEnc(25, -25, 40, 25, degreesElements[indexesNeed[i]] - 20);
        arcEnc(25, -25, 25, 25, 20);
        stopMove(150);
        nowPosition = turnsEncElements[indexesNeed[i]];
        elementsColors[indexesNeed[i]] = -1;
    }

    if (finalPos == 0) {
        short signPos = sgn(nowPosition);
        short angle = angleToEnc(20, 20, 180) - fabs(nowPosition);
        if (signPos > 0){
            smartTurnLeft_enc(40, 80, 60, fabs(angle));
        }
        else{
            smartTurnRight_enc(40, 80, 60, fabs(angle));
        }
    } else {
        short signPos = sgn(nowPosition);
        short angle = fabs(nowPosition);
        if (signPos > 0) {
            arcEnc(-30, -30, -40, -30, fabs(angle));
        } else {
            arcEnc(30, 30, 40, 30, fabs(angle));
        }
    }
}

void takeLeftWelem_norm() {
    stopMove(200);
    arcEnc(30, 30, 100, 30, 35);
    stopMove(200);
    changePosGrabberD(100, grabberD.openMin);
    stopMove(200);
    arcEnc(-30, 30, 100, 30, 130);
    changePosGrabberD(100, grabberD.close);
    arcEnc(-30, 30, 30, 30, 30);
    stopMove(200);
    // changePosGrabberC(60, grabberC.maxUpWithoutShip);
    arcEnc(30, -30, 100, 30, 160);
    stopMove(200);
    arcEnc(-30, -30, -100, -30, 35);
    stopMove(200);
}


void takeRightWelem_norm() {
    stopMove(200);
    arcEnc(-30, -30, -100, -30, 35);
    stopMove(300);
    changePosGrabberD(100, grabberD.openMin);
    stopMove(200);
    arcEnc(-30, 30, 100, 30, 130);
    changePosGrabberD(100, grabberD.close);
    arcEnc(-30, 30, 30, 30, 30);
    stopMove(200);
    // changePosGrabberC(60, grabberC.maxUpWithoutShip);
    arcEnc(30, -30, 100, 30, 160);
    stopMove(200);
    arcEnc(30, 30, 100, 30, 35);
    stopMove(200);
}

void takeSmallShipAndThrowOn() {
    setDefaultLine();
    lineFollowEncoder(70, 70, 70, 50)
    changePosGrabberD(100, grabberD.openMin);
    lineFollowCross(70, 100, 1);
    lineFollowEncoder(100, 100, 100, 50);
    changePosGrabberD(100, grabberD.close);
    lineFollowEncoder(100, 100, 100, 50);
    changePosGrabberC(100, grabberC.maxUpWithoutShip);
    lineFollowEncoder(100, 100, 100, 95);
    lineFollowCross(100, 20, 1);
    stopMove(150);
    changePosGrabberC(100, grabberC.maxUp);
    stopMove(300);
    arcEnc(60, 60, 100, 60, 400);
    arcColor_enc(-60, 60, 100, 80, 700, &CDSensor2, 1);
    arcEnc(-80, 80, 80, 80, 30);
    arcColor_enc(-80, 0, -100, -100, 40, &CDSensor2, 1);
    lineFollowCross(100, 100, 1);
    lineFollowEncoder(100, 100, 50, 850);
    arcAngle(0, 50, 100, 40, 80);
    changePosGrabberC(100, grabberC.upForDrop);
    arcAngle(0, 40, 40, 40, 10);
    stopMove(50);
    arcEnc(30, -30, 30, 30, 25);
    stopMove(450);
    changePosGrabberD(100, grabberD.openMin);
    stopMove(200);
    changePosGrabberC(100, grabberC.maxUpWithoutShip);
    stopMove(200);
    arcColor_angle(70, 0, 100, 50, 80, &CDSensor1, 1);
}



void fromSmallShipToElement() {
    changePosGrabberC(100, grabberC.maxUpWithoutShip);
    setDefaultLine();
    lineFollowCross(80, 100, 2);
    reactiveTurnRight();
}

void takeTwoLastElems() {
    setDefaultLineGreyCross();
    changePosGrabberD(100, grabberD.openMax);
    changePosGrabberC(60, grabberC.upForDrop);
    lineFollowEncoder(100, 100, 30, 380);
    lineFollowCross(30, 20, 1);
    stopMove(250);
    arcEnc(25, -25, 50, 20, 175);
    arcEnc(20, -20, 20, 20, 30);
    changePosGrabberC(30, grabberC.maxDown);
    stopMove(250);
    getElements(markerColors[0], markerColors[1], 2, 1, 1);
    lineFollowEncoder(30, 30, 30, 10);
    changePosGrabberD(100, grabberD.openMin);
    lineFollowEncoder(30, 30, 30, 50);
    changePosGrabberD(100, grabberD.close);
    lineFollowCross(30, 25, 1);
    changePosGrabberC(100, grabberC.maxUpWithoutShip);
    stopMove(200);
}


void takeBigShipAndThrowOn() {
    setDefaultLine();
    arcEnc(25, -25, 25, 25, 100);
    stopMove(200);
    arcAngle(30, 30, 100, 30, 80);
    arcAngle(30, 30, 30, 30, 10);
    stopMove(250);
    arcEnc(-40, 40, 100, 20, 595);
    arcEnc(-20, 20, 20, 20, 100);
    changePosGrabberC(100, grabberC.maxUp);
    arcEnc(-25, 25, 25, 25, 60);
    stopMove(150);
    arcEnc(35, 35, 100, 35, 350);
    arcColor_enc(-40, 40, 100, 45, 580, &CDSensor1, 1);
    arcEnc(-45, 45, 45, 45, 50);
    arcColor_enc(0, 45, 100, 70, 600, &CDSensor1, 1);
    lineFollowEncoder(70, 100, 100, 300, 20);
    lineFollowCross(100, 100, 1, 20);
    lineFollowEncoder(100, 100, 100, 950, 20);

    lineFollowCross(100, 40, 1, 20);
    arcAngle(-40, 0, -100, -40, 90);
    lineFollowEncoder(40, 60, 30, 315);

    stopMove(200);
    arcEnc(40, -40, 100, 30, 300);
    changePosGrabberC(100, grabberC.upForDrop);
    stopMove(500);
    arcEnc(30, -30, 30, 30, 25);
    stopMove(50);
    changePosGrabberD(100, grabberD.openMin);
    stopMove(250);
    changePosGrabberC(100, grabberC.maxUpWithoutShip);
    arcEnc(40, -40, 100, 60, 90);
    smartTurnRight_angle(60, 100, 60);
    stopMove(0);
}

void takeLastWhiteAndFinish(short position=0) {
    lineFollowCross(70, 100, 1);
    changePosGrabberD(100, grabberD.openMax);
    reactiveTurnRight();
    setDefaultLineGreyCross();
    lineFollowEncoder(100, 100, 30, 450);
    lineFollowCross(30, 20, 1);

    stopMove(200);
    changePosGrabberC(30, grabberC.maxDown);
    arcEnc(30, -30, 100, 25, 160);
    stopMove(300);
    if (!position){
        arcEnc(30, 30, 30, 30, 35);
    }
    else{
        arcEnc(-30, -30, -30, -30, 35);
    }

    changePosGrabberD(100, grabberD.openMin);
    stopMove(200);
    arcEnc(-30, 30, 30, 30, 100);
    changePosGrabberD(100, grabberD.close);
    stopMove(200);
    changePosGrabberC(60, grabberC.maxUpWithoutShip);
    arcEnc(30, -30, 30, 30, 100);

    if(!position){
        smartTurnLeft_angle(60, 100, 60, 170);
    }
    else{
        smartTurnRight_angle(60, 100, 60, 170);
    }
    // stopMove(200);
    // changePosGrabberC(60, grabberC.maxDown);
    // arcEnc(40, -40, 100, 25, 220);
    // stopMove(300);
    // getLeftWelem();
    // changePosGrabberC(90, grabberC.maxUpWithoutShip);
    // smartTurnLeft_angle(80, 100, 60, 180);

    setDefaultLine();
    lineFollowCross(80, 100, 1);
    reactiveTurnLeft();
    lineFollowCross(100, 100, 1);
    changePosGrabberC(100, grabberC.upForDrop);
    arcEnc(-100, 100, 100, 40, 90);
    arcAngle(-40, 0, -100, -40, 85);
    stopMove(250);
    changePosGrabberD(60, grabberD.openMin);
    stopMove(200);
    changePosGrabberC(100, grabberC.maxUp);
    arcEnc(30, -30, 60, 30, 30);
    arcAngle(50, 0, 100, 50, 68);
    smartTurnLeft_angle(50, 100, 50, 107);
    lineFollowEncoder(50, 50, 50, 340);
    arcEnc(-50, 50, 50, 25, 340);
    stopMove(200);
}

void takeLastElemAndFinish(short position=0) {
    lineFollowCross(70, 100, 2);
    changePosGrabberC(60, grabberC.maxUpWithoutShip);
    changePosGrabberD(100, grabberD.openMin);
    reactiveTurnRight();
    setDefaultLineGreyCross();
    lineFollowEncoder(100, 100, 30, 450);
    lineFollowCross(30, 20, 1);

    stopMove(200);
    arcEnc(25, -25, 50, 20, 175);
    arcEnc(20, -20, 20, 20, 30);
    changePosGrabberC(50, grabberC.maxDown);
    stopMove(500);

    getElementsByPos(position, 1, 1, 1);
    smartTurnLeft_angle(70, 100, 100, 170);

    setDefaultLine();
    lineFollowCross(80, 100, 1);
    reactiveTurnLeft();
    lineFollowCross(100, 100, 2);
    changePosGrabberC(100, grabberC.upForDrop);
    arcEnc(-100, 100, 100, 40, 90);
    arcAngle(-40, 0, -100, -40, 85);
    stopMove(250);
    changePosGrabberD(60, grabberD.openMin);
    stopMove(200);
    changePosGrabberC(100, grabberC.maxUp);
    arcEnc(30, -30, 60, 30, 30);
    arcAngle(50, 0, 100, 50, 68);
    smartTurnLeft_angle(50, 100, 50, 107);
    lineFollowEncoder(50, 50, 50, 340);
    arcEnc(-50, 50, 50, 25, 340);
    stopMove(200);
}

void readWelems() {
    setDefaultLineGreyCross();
    lineFollowCross(30, 30, 1);
    stopMove(250);
    arcEnc(25, -25, 60, 25, 65);
    stopMove(150);
    arcAngle(-30, -30, -80, -30, 80);
    arcAngle(-30, -30, -30, -30, 10);
    stopMove(200);
    readColors(encodersWelems, welemsColors, 2, &CDSensor3, 0);
    arcEnc(-25, 25, 60, 25, 130);
    arcEnc(-25, 25, 25, 25, 35);
    stopMove(150);
    arcAngle(50, 0, 100, 40, 80);
    arcAngle(40, 0, 40, 40, 10);
    soundColOfElements(welemsColors, 2);
    changePosGrabberC(100, grabberC.maxDown);
    stopMove(450);
    setDefaultLine();
}

void fromWelemsToElems() {
    setDefaultLine();
    lineFollowCross(70, 100, 1);
    reactiveTurnRight();
    lineFollowCross(100, 100, 1);
    reactiveTurnRight();
}

void fromElemesToWelems(){
    setDefaultLine();
    lineFollowCross(50, 100, 1);
    reactiveTurnLeft();
    lineFollowCross(100, 100, 1);
    reactiveTurnLeft();
    setDefaultLineGreyCross();
    lineFollowEncoder(100, 100, 40, 500);
}

void fullRandom() {
    start();
    readingElements();
    int posesToGrab[2] = {-1, -1};
    for (int idx = 0; idx < 4; ++idx) {
        if ((7 - markerColors[0] == elementsColors[idx]) && (!inverseMarkerOnSmallShip[0])){
            if (posesToGrab[0] == -1){
                posesToGrab[0] = idx;
                elementsColors[idx] = -1
                inverseMarkerOnSmallShip[0] = true;
            }
            else if (posesToGrab[1] == -1){
                posesToGrab[1] = idx;
                elementsColors[idx] = -1
                inverseMarkerOnSmallShip[0] = true;
            }
        }

        else if ((7 - markerColors[1] == elementsColors[idx]) && (!inverseMarkerOnSmallShip[1])){
            if (posesToGrab[0] == -1){
                posesToGrab[0] = idx;
                elementsColors[idx] = -1
                inverseMarkerOnSmallShip[1] = true;
            }
            else if (posesToGrab[1] == -1){
                posesToGrab[1] = idx;
                elementsColors[idx] = -1
                inverseMarkerOnSmallShip[1] = true;
            }
        }

        else if ((elementsColors[idx] == 0) && (!whiteOnSmallShip)){
            if (posesToGrab[0] == -1){
                posesToGrab[0] = idx;
                elementsColors[idx] = -1
                whiteOnSmallShip = true;
            }
            else if (posesToGrab[1] == -1){
                whiteOnSmallShip = true;
                elementsColors[idx] = -1
                posesToGrab[1] = idx;
            }
        }
    }

    elemsSmallShip = (int)whiteOnSmallShip + (int)inverseMarkerOnSmallShip[0] + (int)inverseMarkerOnSmallShip[1];

    eraseDisplay();
    displayCenteredTextLine(5, "%d %d", posesToGrab[0], posesToGrab[1]);
    sleep(2000);
    getElementsByPos(posesToGrab[0], posesToGrab[1], elemsSmallShip);
    bool flagElemsForBigShipInWelems = false;

    if (elemsSmallShip == 2){
        takeSmallShipAndThrowOn();
        changePosGrabberC(100, grabberC.maxUpWithoutShip);
        setDefaultLine();
        lineFollowCross(80, 100, 1);
        reactiveTurnRight();
        setDefaultLineGreyCross();
        lineFollowEncoder(100, 100, 40, 450);
        readWelems();
        flagElemsForBigShipInWelems = true;
    }
    else{
        changePosGrabberC(100, grabberC.maxUpWithoutShip);
        fromElemesToWelems();
        readWelems();

        if (posesToGrab[0] != -1){
            posesToGrab[0] = -2;
        }
        if (posesToGrab[1] != -1){
            posesToGrab[1] = -2;
        }

        for (int idx = 0; idx < 2; ++idx) {
            if ((7 - markerColors[0] == welemsColors[idx]) && (!inverseMarkerOnSmallShip[0])){
                if (posesToGrab[0] == -1){
                    posesToGrab[0] = idx;
                    welemsColors[idx] = -1
                    inverseMarkerOnSmallShip[0] = true;
                }
                else if (posesToGrab[1] == -1){
                    posesToGrab[1] = idx;
                    welemsColors[idx] = -1
                    inverseMarkerOnSmallShip[0] = true;
                }
            }

            else if ((7 - markerColors[1] == welemsColors[idx]) && (!inverseMarkerOnSmallShip[1])){
                if (posesToGrab[0] == -1){
                    posesToGrab[0] = idx;
                    welemsColors[idx] = -1
                    inverseMarkerOnSmallShip[1] = true;
                }
                else if (posesToGrab[1] == -1){
                    posesToGrab[1] = idx;
                    welemsColors[idx] = -1
                    inverseMarkerOnSmallShip[1] = true;
                }
            }

            else if ((welemsColors[idx] == 0) && (!whiteOnSmallShip)){
                if (posesToGrab[0] == -1){
                    posesToGrab[0] = idx;
                    welemsColors[idx] = -1
                    whiteOnSmallShip = true;
                }
                else if (posesToGrab[1] == -1){
                    whiteOnSmallShip = true;
                    welemsColors[idx] = -1
                    posesToGrab[1] = idx;
                }
            }
        }

        for (short idx = 0; idx < 2; idx++){
            if (posesToGrab[idx] == 0){
                takeLeftWelem_norm();
            }
            else if (posesToGrab[idx] == 1){
                takeRightWelem_norm();
            }
        }


        arcAngle(0, -50, -100, -50, 93);
        arcEnc(50, -50, 100, 50, 700);
        arcColor_enc(0, -50, 100, 50, 100, &CDSensor2, 1);
        takeSmallShipAndThrowOn();

        if ((welemsColors[0] == markerColors[0]) || (welemsColors[0] == markerColors[1]) || (welemsColors[0] == 0)){
            flagElemsForBigShipInWelems = true;
        }
        else if ((welemsColors[1] == markerColors[0]) || (welemsColors[1] == markerColors[1]) || (welemsColors[1] == 0)){
            flagElemsForBigShipInWelems = true
        }
        if (flagElemsForBigShipInWelems){
            changePosGrabberC(100, grabberC.maxUpWithoutShip);
            setDefaultLine();
            lineFollowCross(80, 100, 1);
            reactiveTurnRight();
            setDefaultLineGreyCross();
            lineFollowEncoder(100, 100, 40, 450);
            lineFollowCross(30, 30, 1);
        }

    }

    int posesBigGrab[2] = {-1, -1};
    if (flagElemsForBigShipInWelems){
        for (short i = 0; i < 2; i++){
            if ((welemsColors[i] == markerColors[0]) && (!markerOnBigShip[0])){
                if (posesBigGrab[0] == -1){
                    posesBigGrab[0] = i;
                    welemsColors[i] = -1
                    markerOnBigShip[0] = true;
                }
                else if(posesBigGrab[1] == -1){
                    posesBigGrab[1] = i;
                    welemsColors[i] = -1
                    markerOnBigShip[0] = true;
                }
            }
            else if ((welemsColors[i] == markerColors[1]) && (!markerOnBigShip[1])){
                if (posesBigGrab[0] == -1){
                    posesBigGrab[0] = i;
                    welemsColors[i] = -1
                    markerOnBigShip[1] = true;
                }
                else if(posesBigGrab[1] == -1){
	                    posesBigGrab[1] = i;
                    welemsColors[i] = -1
                    markerOnBigShip[1] = true;
                }
            }
            else if ((welemsColors[i] == 0) && (!whiteOnBigShip)){
                if (posesBigGrab[0] == -1){
                    posesBigGrab[0] = i;
                    welemsColors[i] = -1
                    whiteOnBigShip = true;
                }
                else if(posesBigGrab[1] == -1){
                    posesBigGrab[1] = i;
                    welemsColors[i] = -1
                    whiteOnBigShip = true;
                }
            }
        }

        for (short idx = 0; idx < 2; idx++){
            if (posesBigGrab[idx] == 0){
                takeLeftWelem_norm();
            }
            else if (posesBigGrab[idx] == 1){
                takeRightWelem_norm();
            }
        }

        smartTurnLeft_angle(50, 100, 80);
        changePosGrabberC(100, grabberC.maxUpWithoutShip);
        fromWelemsToElems();
    }
    else{
        setDefaultLine();
        changePosGrabberC(100, grabberC.maxUpWithoutShip);
        lineFollowCross(80, 100, 2);
        reactiveTurnRight();
    }


    setDefaultLineGreyCross();
    lineFollowEncoder(100, 100, 30, 380);
    lineFollowCross(30, 20, 1);
    stopMove(250);
    arcEnc(25, -25, 50, 20, 175);
    arcEnc(20, -20, 20, 20, 30);
    changePosGrabberC(50, grabberC.maxDown);
    stopMove(500);

    if (posesBigGrab[0] != -1){
        posesBigGrab[0] = -2;
    }
    if (posesBigGrab[1] != -1){
        posesBigGrab[1] = -2;
    }

    for (short i = 0; i < 4; i++){
        if ((elementsColors[i] == markerColors[0]) && (!markerOnBigShip[0])){
            if (posesBigGrab[0] == -1){
                posesBigGrab[0] = i;
                elementsColors[i] = -1;
                markerOnBigShip[0] = true;
            }
            else if(posesBigGrab[1] == -1){
                posesBigGrab[1] = i;
                elementsColors[i] = -1;
                markerOnBigShip[0] = true;
            }
        }
        else if ((elementsColors[i] == markerColors[1]) && (!markerOnBigShip[1])){
            if (posesBigGrab[0] == -1){
                posesBigGrab[0] = i;
                elementsColors[i] = -1;
                markerOnBigShip[1] = true;
            }
            else if(posesBigGrab[1] == -1){
                posesBigGrab[1] = i;
                elementsColors[i] = -1;
                markerOnBigShip[1] = true;
            }
        }
        else if ((elementsColors[i] == 0) && (!whiteOnBigShip)){
            if (posesBigGrab[0] == -1){
                posesBigGrab[0] = i;
                elementsColors[i] = -1;
                whiteOnBigShip = true;
            }
            else if(posesBigGrab[1] == -1){
                posesBigGrab[1] = i;
                elementsColors[i] = -1;
                whiteOnBigShip = true;
            }
        }
    }

    short amountToTake = 0;
    short firstPos = -1;
    short secondPos = -1;

    if (posesBigGrab[0] >= 0){
        amountToTake++;
        firstPos = posesBigGrab[0];
    }
    if (posesBigGrab[1] >= 0){
        amountToTake++;
        if (firstPos == -1){
            firstPos = posesBigGrab[1];
        }
        else{
            secondPos = posesBigGrab[1];
        }

    }

    getElementsByPos(firstPos, secondPos, amountToTake, 1);

    arcEnc(20, -20, 30, 20, 120);
    stopMove(200);
    lineFollowEncoder(30, 30, 30, 10);
    changePosGrabberD(100, grabberD.openMin);
    lineFollowEncoder(30, 30, 30, 50);
    changePosGrabberD(100, grabberD.close);
    lineFollowEncoder(30, 30, 30, 10);
    changePosGrabberC(100, grabberC.maxUpWithoutShip);
    lineFollowCross(30, 25, 1);
    stopMove(200);

    takeBigShipAndThrowOn();

    short posLastElem = -1;
    short needColor = -2;

    if (!markerOnBigShip[0]){
        needColor = markerColors[0];
    }
    else if(!markerOnBigShip[1]){
        needColor = markerColors[1];
    }
    else if(!whiteOnBigShip){
        needColor = 0;
    }


    if (posLastElem == -1){
        for (short i = 0; i < 4; i++){
            if (elementsColors[i] == needColor){
                posLastElem = i;
            }
        }
    }

    takeLastElemAndFinish(posLastElem);
}

task main(){
    initAll();
    unsigned long varPgmTime = nPgmTime;
    float now = getBatteryVoltage();
    now = getBatteryVoltage();
    if (now < 7.8){
        playSound(soundException);
    }

    // stopMove(500);
    // arcAngle(-10, 30, 100, 30, 90);

    // stopMove(123081320);

    stopMove(500);
    fullRandom();
    stopMove(123081320);




    start();
    readingElements();


    getElements(7 - markerColors[0], 7 - markerColors[1], 2);

    takeSmallShipAndThrowOn();

    fromSmallShipToElement();

    takeTwoLastElems();

    takeBigShipAndThrowOn();

    takeLastWhiteAndFinish();

    eraseDisplay();
    displayCenteredTextLine(2, "%d", nPgmTime - varPgmTime);

    stopMove(20000);
    fileClose(fileHandle);
}
